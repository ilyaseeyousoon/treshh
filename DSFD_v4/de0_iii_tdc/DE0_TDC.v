
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE0_TDC(

	//////////// CLOCK //////////
	CLOCK_50,

	//////////// LED //////////
	LED,

	//////////// KEY //////////
	KEY,
	
	SIGNAL,//входной сигнал 
	MOD,//режим гереатора
	MOD_STATIC,
	TRIG,//модуляция 10 кгц
	DAC_OUT,
	DAC_WR,
	DAC2_DB,
	DAC2_WR,
	SW,
	TEST_SIGNAL,
	TEST_SIGNAL2,
	SPI3_CLK,
	SPI3_MOSI,
	SPI3_SS,
	SPI1_MOSI,
	SPI1_SS
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;

//////////// LED //////////
output		     [7:0]		LED;

//////////// KEY //////////
input 		     [2:0]		KEY;

input SIGNAL;
output MOD;
output MOD_STATIC;
output TRIG;
output TEST_SIGNAL;
output TEST_SIGNAL2;

output SPI3_SS;
output SPI3_MOSI;

output SPI1_SS;
output SPI3_CLK;
output SPI1_MOSI;

output[7:0] DAC_OUT,DAC2_DB;
output DAC_WR;
output DAC2_WR;
input[9:0] SW;
//input [3:0] GPIO;
//=======================================================
//  REG/WIRE declarations
//=======================================================
reg[3:0] signal_ctr;
wire[3:0] mods, tdc_dval;
reg[8:0] mod_ctr;
reg[15:0] clk_div;
reg[10:0] clk_10k_d;
reg clk_10k;

wire [7:0] out_data_byass_top ,sin_to_dac ;
wire [8:0] address_to_sin;
assign DAC2_DB = sin_to_dac;
assign DAC2_WR = pll_clk[9];
reg[15:0] clk_div2;
reg[10:0] clk_20k_d;
reg clk_20k;

reg[15:0] clk_div3;
reg[10:0] clk_40k_d;
reg clk_40k;

wire [19:0]result_sum;



wire signal, mod, mod_d, dm_clk, diff_dval, tdc_input_signal, ph_mod;

assign TEST_SIGNAL=SIGNAL;
assign TEST_SIGNAL2=clk_10k;



wire[36:0] tdc_out_0, tdc_out_1, tdc_out_2, tdc_out_3;
wire[19:0] diff_out_0;
wire digmod_out, pll_lock, rst;
wire[9:0] pll_clk, inv_clk;
wire[15:0] tdc_clocks;

//assign inv_clk = ~pll_clk;
assign tdc_clocks = {pll_clk[7:0], inv_clk[7:0]}; //pll clock inversion
assign MOD = ph_mod;
assign MOD_STATIC = clk_10k;
assign DAC_OUT = out_data_byass_top;
assign DAC_WR = diff_dval;
//assign tdc_input_signal = (SW[9]) ? SIGNAL : digmod_out;
assign tdc_input_signal =  SIGNAL;

//pll_clkdiv div_inst (tdc_clocks, rst, LED);
//=======================================================
//  Structural coding
//=======================================================
//assign GPIO[0] = tdc_clocks[0]; //GPIO_00, pin 2
//assign GPIO[2] = tdc_clocks[4]; //GPIO_01, pin 4
//assign GPIO[2] = digmod_out; 	  //GPIO_03, pin 6
//assign GPIO[3] = mod_d;			  //GPIO_05, pin 8

assign rst = 1;
assign pll_rst = 1;
//assign LED[0] = |{tdc_out_0, tdc_out_1, tdc_out_2, tdc_out_3};
//assign LED[1] = tdc_dval;

always @ (posedge pll_clk[0] or negedge rst)
	begin
		if(!rst)
			begin
				clk_div <= 0;
				clk_10k <= 0;
				clk_10k_d <= 0;
			end
		else
			begin	
				if(clk_div == 9999) 
					begin																													
						clk_div = 0;
						clk_10k <= ~clk_10k;
					end
				else clk_div <= clk_div + 1;
				
				clk_10k_d <= {clk_10k_d[9:0], clk_10k};
			end
	end
	
	always @ (posedge pll_clk[0] or negedge rst)
	begin
		if(!rst)
			begin
				clk_div2 <= 0;
				clk_20k <= 0;
				clk_20k_d <= 0;
			end
		else
			begin	
				if(clk_div2 == 4999) 
					begin																													
						clk_div2 = 0;
						clk_20k <= ~clk_20k;
					end
				else clk_div2 <= clk_div2 + 1;
				
				clk_20k_d <= {clk_20k_d[9:0], clk_20k};
			end
	end
	
		always @ (posedge pll_clk[0] or negedge rst)
	begin
		if(!rst)
			begin
				clk_div3 <= 0;
				clk_40k <= 0;
				clk_40k_d <= 0;
			end
		else
			begin	
				if(clk_div3 == 2499) // поменять и протестить работу spi!!!
					begin																													
						clk_div3 = 0;
						clk_40k <= ~clk_40k;
					end
				else clk_div3 <= clk_div3 + 1;
				
				clk_40k_d <= {clk_40k_d[9:0], clk_40k};
			end
	end
	
	
//phase_controller ph_ctl(pll_clk[0], 1, KEY[1:0], SW[0], ph_mod);
  phase_controller ph_ctl(pll_clk[0], 1, KEY[1:0], 1, ph_mod);

//signal_pll pll_sg (.areset(~pll_rst), .inclk0(CLOCK_50), .c0(dm_clk), .c1(mod));

clock_block    cb_inst (CLOCK_50, rst, 1, pll_clk, inv_clk);   
					
dm_min dm_inst (pll_clk[0], rst, clk_10k, digmod_out, mod_d);

	tdc tdc_inst_0 (tdc_clocks, rst, tdc_input_signal, ph_mod, tdc_out_0, tdc_dval[0], TRIG);					
//tdc tdc_inst_0 (tdc_clocks, rst, tdc_input_signal, clk_20k, tdc_out_0, tdc_dval[0], TRIG);
diff diff_inst (tdc_clocks[0], rst, tdc_dval[0], tdc_out_0,clk_10k, diff_out_0, diff_dval);

//byass_data byass_data1( tdc_clocks[0],  rst,  KEY[2:1], diff_out_0, out_data_byass_top);
byass_data byass_data1( tdc_clocks[0],  rst,  KEY[0], diff_out_0,SW[8], out_data_byass_top);

sin_addr sin_addr1 (pll_clk[9],address_to_sin);

singen  singen1 ( address_to_sin,pll_clk[9],sin_to_dac );

//spi_data_transm spi_data_transm1(pll_clk[0],pll_clk[8],clk_40k,SPI3_MOSI,SPI3_CLK,SPI3_SS,result_sum[15:0]);

reg [7:0] temp =0;
wire [15:0] h={diff_out_0[7:0],temp[7:0] };

spi_data_transm spi_data_transm2(pll_clk[0],pll_clk[8],clk_20k,SPI3_MOSI,SPI3_CLK,SPI3_SS,diff_out_0[15:0]);


/*
reg [7:0] temp =0;
wire [15:0] h={sin_to_dac[7:0],temp[7:0] };
wire gg;
spi_data_transm spi_data_transm2(pll_clk[0],pll_clk[8],clk_40k,SPI3_MOSI,SPI3_CLK,SPI3_SS,h);
*/

/*
spi_data_transm spi_data_transm1(pll_clk[0],pll_clk[8],clk_40k,SPI1_MOSI,SPI3_CLK,SPI1_SS,sin_to_dac[7:0]);
wire gg;
spi_data_transm spi_data_transm2(pll_clk[0],pll_clk[8],clk_40k,SPI3_MOSI,gg,SPI3_SS,sin_to_dac[7:0]);
*/

accumulation ( clk_20k,diff_dval,  rst,  diff_out_0[15:0],  result_sum );


endmodule
