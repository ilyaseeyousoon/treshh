
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE0_TDC(

	//////////// CLOCK //////////
	CLOCK_50,

	//////////// LED //////////
	LED,

	//////////// KEY //////////
	KEY,
	
	SIGNAL,//входной сигнал 
	MOD,//режим гереатора
	MOD_STATIC,
	TRIG,//модуляция 10 кгц
	DAC_OUT,
	DAC_WR,
	DAC2_DB,
	DAC2_WR,
	SW,
	TEST_SIGNAL,
	TEST_SIGNAL2,
	SPI3_CLK,
	SPI3_MOSI,
	SPI3_SS,
	SPI1_MOSI,
	SPI1_SS,
	TxD_direct,
	TxD,
	SEG_2DP,
	SEG_3DP,
	SEG_1DP,
	SEG_0DP,
	SEG_0,
	SEG_1,
	SEG_2,
	SEG_3
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;

//////////// LED //////////
output		     [7:0]		LED;

//////////// KEY //////////
input 		     [2:0]		KEY;

input SIGNAL;
output MOD;
output MOD_STATIC;
output TRIG;
output TEST_SIGNAL;
output TEST_SIGNAL2;

output SPI3_SS;
output SPI3_MOSI;

output SPI1_SS;
output SPI3_CLK;
output SPI1_MOSI;

output TxD;
output TxD_direct;

output wire	SEG_2DP;
output wire	SEG_3DP;
output wire	SEG_1DP;
output wire	SEG_0DP;
output wire	[6:0] SEG_0;
output wire	[6:0] SEG_1;
output wire	[6:0] SEG_2;
output wire	[6:0] SEG_3;

output[7:0] DAC_OUT,DAC2_DB;
output DAC_WR;
output DAC2_WR;
input[9:0] SW;
//input [3:0] GPIO;
//=======================================================
//  REG/WIRE declarations
//=======================================================
reg[3:0] signal_ctr;
wire[3:0] mods, tdc_dval;
reg[8:0] mod_ctr;
reg[15:0] clk_div;
reg[10:0] clk_10k_d;
reg clk_10k;

wire [7:0] out_data_byass_top ,sin_to_dac ;
wire [8:0] address_to_sin;
assign DAC2_DB = sin_to_dac;
assign DAC2_WR = pll_clk[9];
reg[15:0] clk_div2;
reg[10:0] clk_20k_d;
reg clk_20k;

reg[15:0] clk_div3;
reg[10:0] clk_40k_d;
reg clk_40k;

reg[15:0] clk_div4;
reg[10:0] clk_20m_d;
reg clk_20m;

wire [19:0]result_sum;



wire signal, mod, mod_d, dm_clk, diff_dval, tdc_input_signal, ph_mod;

assign TEST_SIGNAL=ff;
assign TEST_SIGNAL2=TxD_direct;



wire[36:0] tdc_out_0, tdc_out_1, tdc_out_2, tdc_out_3;
wire[19:0] diff_out_0;
wire digmod_out, pll_lock, rst;
wire[9:0] pll_clk, inv_clk;
wire[15:0] tdc_clocks;

//assign inv_clk = ~pll_clk;
assign tdc_clocks = {pll_clk[7:0], inv_clk[7:0]}; //pll clock inversion
assign MOD = ph_mod;
assign MOD_STATIC = clk_10k;
assign DAC_OUT = out_data_byass_top;
assign DAC_WR = diff_dval;
//assign tdc_input_signal = (SW[9]) ? SIGNAL : digmod_out;
assign tdc_input_signal =  SIGNAL;

//pll_clkdiv div_inst (tdc_clocks, rst, LED);
//=======================================================
//  Structural coding
//=======================================================
//assign GPIO[0] = tdc_clocks[0]; //GPIO_00, pin 2
//assign GPIO[2] = tdc_clocks[4]; //GPIO_01, pin 4
//assign GPIO[2] = digmod_out; 	  //GPIO_03, pin 6
//assign GPIO[3] = mod_d;			  //GPIO_05, pin 8

assign rst = 1;
assign pll_rst = 1;
//assign LED[0] = |{tdc_out_0, tdc_out_1, tdc_out_2, tdc_out_3};
//assign LED[1] = tdc_dval;

always @ (posedge pll_clk[0] or negedge rst)
	begin
		if(!rst)
			begin
				clk_div <= 0;
				clk_10k <= 0;
				clk_10k_d <= 0;
			end
		else
			begin	
				if(clk_div == 9999) 
					begin																													
						clk_div = 0;
						clk_10k <= ~clk_10k;
					end
				else clk_div <= clk_div + 1;
				
				clk_10k_d <= {clk_10k_d[9:0], clk_10k};
			end
	end
	
	always @ (posedge pll_clk[0] or negedge rst)
	begin
		if(!rst)
			begin
				clk_div2 <= 0;
				clk_20k <= 0;
				clk_20k_d <= 0;
			end
		else
			begin	
				if(clk_div2 == 4999) 
					begin																													
						clk_div2 = 0;
						clk_20k <= ~clk_20k;
					end
				else clk_div2 <= clk_div2 + 1;
				
				clk_20k_d <= {clk_20k_d[9:0], clk_20k};
			end
	end
	
		always @ (posedge pll_clk[0] or negedge rst)
	begin
		if(!rst)
			begin
				clk_div3 <= 0;
				clk_40k <= 0;
				clk_40k_d <= 0;
			end
		else
			begin	
				if(clk_div3 == 2499) // поменять и протестить работу spi!!!
					begin																													
						clk_div3 = 0;
						clk_40k <= ~clk_40k;
					end
				else clk_div3 <= clk_div3 + 1;
				
				clk_40k_d <= {clk_40k_d[9:0], clk_40k};
			end
	end
	
			always @ (posedge pll_clk[0] or negedge rst)
	begin
		if(!rst)
			begin
				clk_div4 <= 0;
				clk_20m <= 0;
				clk_20m_d <= 0;
			end
		else
			begin	
				if(clk_div4 == 3) // поменять и протестить работу spi!!!
					begin																													
						clk_div4 = 0;
						clk_20m <= ~clk_20m;
					end
				else clk_div4 <= clk_div4 + 1;
				
				clk_20m_d <= {clk_20m_d[9:0], clk_20m};
			end
	end
	
	
	
	
	reg [7:0] temp =0;
		reg [4:0] horrible_counter,horrible_counter_2= 5'd0;
	reg key_flag,key_flag_2=0;
	reg [15:0] result_biass,result_biass_2,diff_out_temp=0;
	
			always @ (posedge clk_40k or negedge rst)
	begin
		if(!rst)
			begin
				horrible_counter <= 5'd0;
				key_flag<=0;
				horrible_counter_2 <= 5'd0;
				key_flag_2<=0;
			end
		else
			begin	
				if(SW[3]==1 && key_flag==0) begin
				  horrible_counter<=horrible_counter+1;
				  key_flag<=1;
				  end
				  else begin
				  if(SW[3]==0)
				  key_flag<=0;
				  
				  if(horrible_counter>8)
				  horrible_counter<=0;
				  
				  end 
				  // второй
				  if(SW[4]==1 && key_flag_2==0) begin
				  horrible_counter_2<=horrible_counter_2+1;
				  key_flag_2<=1;
				  end
				  else begin
				  if(SW[4]==0)
				  key_flag_2<=0;
				  
				  if(horrible_counter_2>8)
				  horrible_counter_2<=0;
				  
				  end 
				  
				  
	/*			  
				  	case(horrible_counter[4:0])
	0: 	begin result_biass=result_sum[15:0]; end
	1:		begin result_biass={result_sum[14:0],temp[0]};   end
	2:		begin result_biass={result_sum[13:0],temp[1:0]}; end
	3:		begin result_biass={result_sum[12:0],temp[2:0]}; end
	4:		begin result_biass={result_sum[11:0],temp[3:0]}; end
	5:		begin result_biass={result_sum[10:0],temp[4:0]}; end
	6:		begin result_biass={result_sum[9:0],temp[5:0]}; end
	7:		begin result_biass={result_sum[8:0],temp[6:0]}; end
	8:		begin result_biass={result_sum[7:0],temp[7:0]}; end
	9:		begin result_biass={result_sum[7:0],temp[7:0]}; end
	endcase
		*/	
				case(horrible_counter[4:0])
   0:		begin result_biass=result_sum[15:0]+16'd30000; end
	1:		begin diff_out_temp=result_sum[15:0]+16'd16383;   
	result_biass={diff_out_temp[14:0],temp[0]};   end
	2:		begin diff_out_temp=result_sum[15:0]+16'd8191;   
	result_biass={diff_out_temp[13:0],temp[1:0]};   end
	3:		begin diff_out_temp=result_sum[15:0]+16'd4095;   
	result_biass={diff_out_temp[12:0],temp[2:0]};   end
	4:		begin diff_out_temp=result_sum[15:0]+16'd2047;   
	result_biass={diff_out_temp[11:0],temp[3:0]};   end	
	5:		begin diff_out_temp=result_sum[15:0]+16'd1023;   
	result_biass={diff_out_temp[10:0],temp[4:0]};   end	
	6:		begin diff_out_temp=result_sum[15:0]+16'd511;   
	result_biass={diff_out_temp[9:0],temp[5:0]};   end	
	7:		begin diff_out_temp=result_sum[15:0]+16'd255;   
	result_biass={diff_out_temp[8:0],temp[6:0]};   end	
	8:		begin diff_out_temp=result_sum[15:0]+16'd125;   
	result_biass={diff_out_temp[7:0],temp[7:0]};   end
	9:		begin diff_out_temp=result_sum[15:0]+16'd125;   
	result_biass={diff_out_temp[7:0],temp[7:0]};   end	
	endcase
	
	
				case(horrible_counter_2[4:0])
   0:		begin result_biass_2=diff_out_0[15:0]+16'd32767; end
	1:		begin diff_out_temp=diff_out_0[15:0]+16'd16383;   
	result_biass_2={diff_out_temp[14:0],temp[0]};   end
	2:		begin diff_out_temp=diff_out_0[15:0]+16'd8191;   
	result_biass_2={diff_out_temp[13:0],temp[1:0]};   end
	3:		begin diff_out_temp=diff_out_0[15:0]+16'd4095;   
	result_biass_2={diff_out_temp[12:0],temp[2:0]};   end
	4:		begin diff_out_temp=diff_out_0[15:0]+16'd2047;   
	result_biass_2={diff_out_temp[11:0],temp[3:0]};   end	
	5:		begin diff_out_temp=diff_out_0[15:0]+16'd1023;   
	result_biass_2={diff_out_temp[10:0],temp[4:0]};   end	
	6:		begin diff_out_temp=diff_out_0[15:0]+16'd511;   
	result_biass_2={diff_out_temp[9:0],temp[5:0]};   end	
	7:		begin diff_out_temp=diff_out_0[15:0]+16'd255;   
	result_biass_2={diff_out_temp[8:0],temp[6:0]};   end	
	8:		begin diff_out_temp=diff_out_0[15:0]+16'd125;   
	result_biass_2={diff_out_temp[7:0],temp[7:0]};   end
	9:		begin diff_out_temp=diff_out_0[15:0]+16'd125;   
	result_biass_2={diff_out_temp[7:0],temp[7:0]};   end	
	endcase
	
			end
	end
	

	
//phase_controller ph_ctl(pll_clk[0], 1, KEY[1:0], SW[0], ph_mod);
  phase_controller ph_ctl(pll_clk[0], 1, KEY[1:0], SW[1:0], ph_mod);

//signal_pll pll_sg (.areset(~pll_rst), .inclk0(CLOCK_50), .c0(dm_clk), .c1(mod));

clock_block    cb_inst (CLOCK_50, rst, 1, pll_clk, inv_clk);   
					
dm_min dm_inst (pll_clk[0], rst, clk_10k, digmod_out, mod_d);

	tdc tdc_inst_0 (tdc_clocks, rst, tdc_input_signal, ph_mod, tdc_out_0, tdc_dval[0], TRIG);					
//tdc tdc_inst_0 (tdc_clocks, rst, tdc_input_signal, clk_20k, tdc_out_0, tdc_dval[0], TRIG);
diff diff_inst (tdc_clocks[0], rst, tdc_dval[0], tdc_out_0,clk_10k, diff_out_0, diff_dval);

//byass_data byass_data1( tdc_clocks[0],  rst,  KEY[2:1], diff_out_0, out_data_byass_top);
byass_data byass_data1( tdc_clocks[0],  rst,  KEY[0], diff_out_0,SW[8], out_data_byass_top);

sin_addr sin_addr1 (pll_clk[9],address_to_sin);

singen  singen1 ( address_to_sin,pll_clk[9],sin_to_dac );

//spi_data_transm spi_data_transm1(pll_clk[0],pll_clk[8],clk_40k,SPI3_MOSI,SPI3_CLK,SPI3_SS,result_sum[15:0]);

//reg [7:0] temp =0;
//wire [15:0] h={diff_out_0[7:0],temp[7:0] };
 

/*
reg [7:0] temp =0;
wire [15:0]  data_to_spi = SW[2] ? {diff_out_spi[7:0],temp[7:0]} : diff_out_spi[19:0];
wire [19:0] diff_out_spi= SW[2]	? diff_out_0+ 20'd125 : diff_out_0+ 20'd30000;
*/
spi_data_transm spi_data_transm(pll_clk[0],pll_clk[8],clk_10k,SPI3_MOSI,SPI3_CLK,SPI3_SS,result_biass[15:0]);

accumulation ( ph_mod,diff_dval,  rst,  diff_out_0[15:0],  result_sum );
//wire [15:0] h={result_sum[7:0],temp[7:0] };
wire gg;
spi_data_transm spi_data_transm1(pll_clk[0],pll_clk[8],clk_20k,SPI1_MOSI,gg,SPI1_SS,result_biass_2[15:0]);

wire ff,ff_2;

//*********************************************//

//TEST ВЕРСИЯ МОДУЛЯ ДЛЯ ПРОВЕРКИ В МАТЛАБЕ
 //UART uart_test( clk_20m,16'd42053, clk_20k, TxD_direct, ff);

 // Рабочая версия uart
 UART uart_test( clk_20m,{temp[7:0],result_biass_2[15:0]}, clk_40k, TxD_direct, ff);
 
 wire Tdx_temp;
 assign TxD=~Tdx_temp;
 
 SEG7_LUT test_led1	(	SEG_1,SEG_1DP,horrible_counter_2	);
 SEG7_LUT test_led2	(	SEG_2,SEG_2DP,horrible_counter_2	);
  SEG7_LUT test_led3	(	SEG_3,SEG_3DP,horrible_counter_2	);
   SEG7_LUT test_led0	(	SEG_0,SEG_0DP,horrible_counter_2	);
 
 
 

/*
reg  [23:0]count_test=24'd0;
always @ (posedge clk_20k )
begin


count_test<=count_test+1;
end
*/


/*
reg [7:0] temp =0;
wire [19:0] result_sum_2 =result_sum[19:0]-20'd80;
wire [15:0]temp2= {result_sum_2[7:0],temp[7:0]};
*/
/*
//проверка шума
reg [7:0] temp =0;
wire [15:0]temp2= {diff_out_0[7:0],temp[5:0]};
*/

endmodule
